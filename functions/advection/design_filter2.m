function fft_filter = design_filter2(model,sigma_filter)
% Design a Gaussian filter for smoothing between forward and backward
% advection
%

% %% Get parameters
% sigma_filter=model.advection.sigma_filter;

%% Grid
sigma_filter = sigma_filter/sqrt(prod(model.grid.dX)); % 0.36 degre
% fft_filter = (2*pi* sigma_filter^2) * ...
% x= model.grid.dX(1)*(0:model.grid.MX(1)-1);
% y= model.grid.dX(2)*(0:model.grid.MX(2)-1);
x= model.grid.dX(1)*(0:model.grid.MX(1)-1);
% if model.mirror
%     y= model.grid.dX(2)*(0:2*model.grid.MX(2)-1);
% else
    y= model.grid.dX(2)*(0:model.grid.MX(2)-1);
% end
[x,y]=ndgrid(x,y);

%% Filter
% fft_filter = exp( - 2*(pi*sigma_filter)^2 * ...
fft_filter = exp( - (1/2)*(sigma_filter)^2 * ...
    (  ((x-x(1,1))/(model.grid.dX(1)*model.grid.MX(1)*sqrt(model.grid.dX(2)/model.grid.dX(1)))).^2 ...
    + ((y-y(1,1))/(model.grid.dX(2)*2*model.grid.MX(2)*sqrt(model.grid.dX(1)/model.grid.dX(2)))).^2 ) )...
    + exp( - 2*(pi*sigma_filter)^2 * ...
    (  ((x-x(1,end))/(model.grid.dX(1)*model.grid.MX(1)*sqrt(model.grid.dX(2)/model.grid.dX(1)))).^2 ...
    + ((y-y(1,end))/(model.grid.dX(2)*2*model.grid.MX(2)*sqrt(model.grid.dX(1)/model.grid.dX(2)))).^2 ) )...
    + exp( - 2*(pi*sigma_filter)^2 * ...
    (  ((x-x(end,1))/(model.grid.dX(1)*model.grid.MX(1)*sqrt(model.grid.dX(2)/model.grid.dX(1)))).^2 ...
    + ((y-y(end,1))/(model.grid.dX(2)*2*model.grid.MX(2)*sqrt(model.grid.dX(1)/model.grid.dX(2)))).^2 ) )...
    + exp( - 2*(pi*sigma_filter)^2 * ...
    (  ((x-x(end,end))/(model.grid.dX(1)*model.grid.MX(1)*sqrt(model.grid.dX(2)/model.grid.dX(1)))).^2 ...
    + ((y-y(end,end))/(model.grid.dX(2)*2*model.grid.MX(2)*sqrt(model.grid.dX(1)/model.grid.dX(2)))).^2 ) );

%     fft_filter = exp( - 2*(pi*sigma_filter)^2 * ...
%         (  ((x-x(1,1))/(model.grid.dX(1)*model.grid.MX(1)*sqrt(model.grid.dX(2)/model.grid.dX(1)))).^2 ...
%         + ((y-y(1,1))/(model.grid.dX(2)*model.grid.MX(2)*sqrt(model.grid.dX(1)/model.grid.dX(2)))).^2 ) )...
%         + exp( - 2*(pi*sigma_filter)^2 * ...
%         (  ((x-x(1,end))/(model.grid.dX(1)*model.grid.MX(1)*sqrt(model.grid.dX(2)/model.grid.dX(1)))).^2 ...
%         + ((y-y(1,end))/(model.grid.dX(2)*model.grid.MX(2)*sqrt(model.grid.dX(1)/model.grid.dX(2)))).^2 ) )...
%         + exp( - 2*(pi*sigma_filter)^2 * ...
%         (  ((x-x(end,1))/(model.grid.dX(1)*model.grid.MX(1)*sqrt(model.grid.dX(2)/model.grid.dX(1)))).^2 ...
%         + ((y-y(end,1))/(model.grid.dX(2)*model.grid.MX(2)*sqrt(model.grid.dX(1)/model.grid.dX(2)))).^2 ) )...
%         + exp( - 2*(pi*sigma_filter)^2 * ...
%         (  ((x-x(end,end))/(model.grid.dX(1)*model.grid.MX(1)*sqrt(model.grid.dX(2)/model.grid.dX(1)))).^2 ...
%         + ((y-y(end,end))/(model.grid.dX(2)*model.grid.MX(2)*sqrt(model.grid.dX(1)/model.grid.dX(2)))).^2 ) );
%     % fft_filter(1,1)=1 so the integral (the sum of terms) of the spatial
%     % filter is =1
%
%     % fft_filter = (2*(pi* sigma_filter)^2/prod(model.grid.MX)) * ...
%     %     exp( - 2*(pi*sigma_filter)^2 * ...
%     %     (  ((x-x(1,1))/(model.grid.dX(1)*model.grid.MX(1)*sqrt(model.grid.dX(2)/model.grid.dX(1)))).^2 ...
%     %      + ((y-y(1,1))/(model.grid.dX(2)*model.grid.MX(2)*sqrt(model.grid.dX(1)/model.grid.dX(2)))).^2 ) );
%     % % fft_filter = 1/prod(model.grid.dX) * (2*pi* sigma_filter^2) * ...
%     % %     exp( - 2*(pi*sigma_filter)^2 * ...
%     % %     ( ( (x-x(1,1))/model.grid.dX(1)^2).^2 + ((y-y(1,1))/model.grid.dX(2)^2).^2 ) );
%     % % fft_filter = 1/prod(model.grid.dX) * 1/(2*pi* sigma_filter^2) * ...
%     % %     exp( - 1/(2*sigma_filter^2) * ...
%     % %     ( ( (x-x(1,1))/model.grid.dX(1)^2).^2 + ((y-y(1,1))/model.grid.dX(2)^2).^2 ) );
%     % fft_filter=fft_filter/sum(sum(fft_filter));
%
% figure;
% pcolor(fft_filter)